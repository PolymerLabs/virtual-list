<html>

<head>
  <title>Fallback element</title>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes">

  <style>
    body {
      font-family: Roboto, Helvetica, sans-serif;
      max-width: 600px;
      margin: 10px auto;
    }

    virtual-list {
      width: 100%;
      height: 50vh;
      margin: 10px 0;
      border-top: 2px solid #eee;
      border-bottom: 2px solid #eee;
    }

    fallback-element {
      display: block;
      width: 100%;
      text-align: center;
      line-height: 80px;
      border-bottom: 1px solid #eee;
      animation: inverse-color 1000ms infinite;
    }

    @keyframes inverse-color {
      50% {
        background-color: #ddd;
        color: white;
      }
    }
  </style>
</head>

<body>
  <p>
    <label>
      Server response time (ms):
      <input type="number" value=1000 min=0 max=10000 onchange="updateDelay(this)">
    </label>
  </p>

  <virtual-list></virtual-list>

  <script type="module">
    import '../virtual-list-element.js';
    import './contacts/contact-element.js';

    const fallbackHeight = 80;
    const fallbacksCount = Math.ceil(innerHeight / fallbackHeight) + 5;
    const fallbacks = [];
    for (let i = 0; i < fallbacksCount; i++) {
      fallbacks.push({ fallback: true, guid: 'fallback' + i, index: i });
    }

    // Make a copy of the fallbacks.
    const items = fallbacks.slice();

    const nodePool = {
      'fallback-element': [],
      'contact-element': []
    };
    const virtualList = document.querySelector('virtual-list');
    Object.assign(virtualList, {
      newChild(contact) {
        const type = contact.fallback ? 'fallback-element' : 'contact-element';
        return nodePool[type].pop() || document.createElement(type);
      },
      updateChild(element, contact) {
        if (contact.fallback) {
          element.textContent = '... Loading ...';
          element.style.animationDelay = (50 * contact.index) + 'ms';
        } else {
          element.contact = contact;
        }
      },
      recycleChild(element) {
        nodePool[element.localName].push(element);
      },
      itemKey(contact) {
        return contact.guid;
      },
      items,
    });

    let delayMs = 1000;
    let isLoading = false;
    let allContacts = null;
    loadMore();

    window.updateDelay = updateDelay;

    async function loadMore() {
      if (isLoading) return;
      isLoading = true;

      virtualList.removeEventListener('rangechange', onRangechange);

      const newContacts = await getContacts();

      const i = items.length - fallbacksCount;
      if (newContacts.length) {
        // Keep fallbacks, insert newContacts.
        items.splice(i, 0, ...newContacts);
        virtualList.addEventListener('rangechange', onRangechange);
      } else {
        // Loaded all contacts! Remove fallbacks.
        items.splice(i, fallbacksCount);
      }
      virtualList.requestReset();

      isLoading = false;
    }

    async function getContacts() {
      if (!allContacts) {
        allContacts = await fetch('contacts/contacts.json').then(resp => resp.json());
      }
      // Simulate slow server load...
      await new Promise(resolve => setTimeout(resolve, delayMs));
      return allContacts.splice(0, fallbacksCount);
    }

    function onRangechange(range) {
      if (range.last > items.length - fallbacksCount) {
        loadMore();
      }
    }

    function updateDelay(delayEl) {
      delayMs = delayEl.valueAsNumber;
      if (Number.isNaN(delayMs)) {
        // Default.
        delayMs = 1000;
      } else {
        // Force min/max.
        delayMs = Math.max(
          Number.parseInt(delayEl.min),
          Math.min(delayMs, Number.parseInt(delayEl.max))
        );
      }
      delayEl.value = delayMs;
    };
  </script>
</body>

</html>