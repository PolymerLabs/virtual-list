<html>

<head>
  <title>Fallback element</title>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes">

  <style>
    body {
      font-family: Roboto, Helvetica, sans-serif;
      max-width: 600px;
      margin: 10px auto;
      display: flex;
      flex-direction: column;
    }

    virtual-list {
      width: 100%;
      height: 100%;
      flex: 1;
      margin: 10px 0;
      border-top: 2px solid #eee;
      border-bottom: 2px solid #eee;
    }

    contact-element {
      height: 80px;
    }

    @keyframes inverse-color {
      50% {
        background-color: #ddd;
        color: white;
      }
    }
  </style>
</head>

<body>
  <p>
    <label>
      Server response time (ms):
      <input type="number" value=1000 min=0 max=10000 onchange="updateDelay(this)">
    </label>
  </p>

  <virtual-list></virtual-list>

  <script type="module">
    import '../virtual-list-element.js';
    import './contacts/contact-element.js';
    import { ContactDataSource } from './contacts/contact-data-source.js';

    /**
     * 1. A fallback item has the same shape as a contact item, with an additional
     * field `customAnimation`.
     * 2. Both fallbacks and contacts are represented with <contact-element>
     * 3. We load more contacts when user scrolls to the end of the list
     * (listen for `rangechange`)
     */

    const dataSource = new ContactDataSource();
    const virtualList = document.querySelector('virtual-list');
    const fallbacks = getFallbacks(virtualList.offsetHeight);
    let firstFallbackIndex = 0;
    let lastVisibleIndex = -1;

    virtualList.newChild = (contact) => document.createElement('contact-element');
    virtualList.updateChild = (element, contact) => {
      element.style.animation = contact.customAnimation;
      element.contact = contact;
    };
    // Start with fallbacks.
    virtualList.items = [...fallbacks];

    virtualList.addEventListener('rangechange', (range) => {
      lastVisibleIndex = range.last;
      if (lastVisibleIndex >= firstFallbackIndex) {
        loadMore();
      }
    });

    async function loadMore() {
      if (dataSource.loading || dataSource.loadedAll) return;
      // Load 10x contacts so user has room to scroll once they're loaded.
      const newContacts = await dataSource.getContacts(fallbacks.length * 10);
      if (dataSource.loadedAll) {
        virtualList.items.splice(firstFallbackIndex, fallbacks.length, ...newContacts);
        firstFallbackIndex = Infinity;
      } else {
        virtualList.items.splice(firstFallbackIndex, 0, ...newContacts);
        firstFallbackIndex += newContacts.length;
      }
      virtualList.requestReset();
      // We need to keep loading if the list is scrolled to the end.
      if (lastVisibleIndex >= firstFallbackIndex) {
        loadMore();
      }
    }

    function getFallbacks(viewportHeight) {
      // Compute how many <contact-element> can fit in the virtual-list height.
      const elementHeight = 80;
      // We want enough fallbacks to cover the viewport height.
      const count = Math.ceil(viewportHeight / elementHeight);
      const fallbacks = [];
      for (let i = 0; i < count; i++) {
        fallbacks.push({
          name: 'Loading...',
          image: null,
          customAnimation: `inverse-color 1000ms ${i * 50}ms infinite`,
        });
      }
      return fallbacks;
    }

    window.updateDelay = function updateDelay(delayEl) {
      let delay = delayEl.valueAsNumber;
      if (Number.isNaN(delay)) {
        // Default.
        delay = 1000;
      } else {
        // Force min/max.
        delay = Math.max(
          Number.parseInt(delayEl.min),
          Math.min(delay, Number.parseInt(delayEl.max))
        );
      }
      delayEl.value = delay;
      dataSource.delay = delay;
    };
  </script>
</body>

</html>